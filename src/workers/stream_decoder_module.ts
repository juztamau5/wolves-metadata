/*
 * Copyright (C) 2021 The Wolfpack
 * This file is part of wolves-metadata - https://github.com/wolvesofwallstreet/wolves-metadata
 *
 * SPDX-License-Identifier: Apache-2.0
 * See LICENSE.txt for more information.
 */

import { Observable, Subject } from "threads/observable";
import { expose, Transfer } from "threads/worker";

import Module from "../../test/generated/stream_decoder.js";

// Streaming decoder
let decoder: typeof Module.StreamDecoder;

// Streaming worker results
const metadataAvailableSubject = new Subject();
const frameAvailableSubject = new Subject();
const videoEndedSubject = new Subject();

// Promise that is resolved when module runtime is initialized
let resolveInitialize: () => void;
const runtimeInitialized = new Promise((resolve) => {
  resolveInitialize = () => {
    resolve(null);
  };
});

// Called when WASM module is initialized
Module.onRuntimeInitialized = () => {
  resolveInitialize();
};

// This method will be called when the runtime needs to load a file, such as
// a .wasm WebAssembly file, .mem memory init file, or a file generated by the
// file packager.
//
// The function receives the relative path to the file as configured in build
// process and a prefix (path to the main JavaScript fileâ€™s directory), and
// should return the actual URL.
Module["locateFile"] = function (path: string, prefix: string): string {
  // Use the default, the prefix (JS file's dir) + the path
  return prefix + path;
};

const streamDecoder = {
  async initialize(
    fileName: string,
    blockSize: number,
    maxDecodedSize: number
  ): Promise<void> {
    await runtimeInitialized;

    decoder = new Module.StreamDecoder(
      new TextEncoder().encode(fileName),
      blockSize,
      maxDecodedSize
    );
  },

  async addPacket(
    packetBuffer: Uint8Array,
    byteOffset: number,
    byteLength: number
  ): Promise<boolean> {
    if (!decoder) {
      throw new Error("Stream decoder is not initialized");
    }

    const packetData = new Uint8ClampedArray(
      packetBuffer,
      byteOffset,
      byteLength
    );

    decoder.addPacket(packetData);
    const state: typeof Module.StreamDecoderState = decoder.state;

    if (state == Module.StreamDecoderState.Failed) {
      return false;
    }

    return true;
  },

  async openVideo(): Promise<boolean> {
    if (!decoder.openVideo()) return false;

    const frameSize: number = decoder.frameSize;
    const frameWidth: number = decoder.frameWidth;
    const frameHeight: number = decoder.frameHeight;

    metadataAvailableSubject.next({ frameSize, frameWidth, frameHeight });

    return true;
  },

  async decode(): Promise<boolean> {
    for (;;) {
      const state: typeof Module.StreamDecoderState = decoder.state;

      switch (state) {
        case Module.StreamDecoderState.HasFrame: {
          const frameData = decoder.getFrame();
          const frameSize = decoder.frameSize;

          // Get reference to WASM memory holding the frame
          const src = new Uint8ClampedArray(
            Module.HEAPU8.buffer,
            frameData,
            frameSize
          );

          // Allocate new pixel data
          const videoBuffer = new ArrayBuffer(frameSize);
          const dest = new Uint8Array(videoBuffer);

          // Copy pixels
          dest.set(src);

          frameAvailableSubject.next(Transfer(dest.buffer));
          return true;
        }

        case Module.StreamDecoderState.Ended: {
          onVideoEnded.next();
          return false;
        }

        case Module.StreamDecoderState.Failed: {
          throw new Error("Streaming decoder failed. See log for error");
        }
      }

      decoder.decode();
    }
  },

  onMetadataAvailable(): Observable<unknown> {
    return Observable.from(metadataAvailableSubject);
  },

  onFrameAvailable(): Observable<unknown> {
    return Observable.from(frameAvailableSubject);
  },

  onVideoEnded(): Observable<unknown> {
    return Observable.from(videoEndedSubject);
  },
};

expose(streamDecoder);
