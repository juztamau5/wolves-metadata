/*
 * Copyright (C) 2021 The Wolfpack
 * This file is part of wolves-metadata - https://github.com/wolvesofwallstreet/wolves-metadata
 *
 * SPDX-License-Identifier: Apache-2.0
 * See LICENSE.txt for more information.
 */

import { Observable, Subject } from "threads/observable";
import { expose, Transfer } from "threads/worker";

import Module from "../../test/generated/stream_decoder.js";

// Streaming decoder
let decoder: typeof Module.StreamDecoder;

// Streaming worker results
const metadataAvailableSubject = new Subject();
const frameAvailableSubject = new Subject();

// Promise that is resolved when module runtime is initialized
let resolveInitialize: () => void;
const runtimeInitialized = new Promise((resolve) => {
  resolveInitialize = () => {
    resolve(null);
  };
});

// Called when WASM module is initialized
Module.onRuntimeInitialized = () => {
  resolveInitialize();
};

// This method will be called when the runtime needs to load a file, such as
// a .wasm WebAssembly file, .mem memory init file, or a file generated by the
// file packager.
//
// The function receives the relative path to the file as configured in build
// process and a prefix (path to the main JavaScript fileâ€™s directory), and
// should return the actual URL.
Module["locateFile"] = function (path: string, prefix: string): string {
  // Use the default, the prefix (JS file's dir) + the path
  return prefix + path;
};

const streamDecoder = {
  /**
   * @brief Initialize the stream decoder
   *
   * @param fileName The name of the video file
   * @param blockSize The video file chunk size, or 0 for unknown
   * @param maxDecodedSize A limit to the resolution of the decoded frame
   *
   * Frame dimensions will be halved until both dimensions are below the max
   * decoded size.
   */
  async initialize(
    fileName: string,
    blockSize: number,
    maxDecodedSize: number
  ): Promise<void> {
    await runtimeInitialized;

    decoder = new Module.StreamDecoder(
      new TextEncoder().encode(fileName),
      blockSize,
      maxDecodedSize
    );
  },

  /**
   * @brief Open a video file for decoding
   *
   * @returns True if the video file was opened, false on error
   */
  async openVideo(): Promise<boolean> {
    if (!decoder.openVideo()) {
      return false;
    }

    const frameSize: number = decoder.frameSize;
    const frameWidth: number = decoder.frameWidth;
    const frameHeight: number = decoder.frameHeight;

    metadataAvailableSubject.next({ frameSize, frameWidth, frameHeight });

    return true;
  },

  /**
   * @brief Close a video file being decoding
   *
   * This should be called if openVideo() returned true.
   */
  async closeVideo(): Promise<void> {
    decoder.closeVideo();
  },

  /**
   * @brief Add a packet to the decoder
   *
   * @param packetBuffer The packet data
   * @param byteOffset The offset into the data where the packet starts
   * @param byteLength The length of the packet data
   *
   * @returns True if the packet was added, false on error
   *
   * TODO: Handle EOF better
   */
  async addPacket(
    packetBuffer: Uint8Array,
    byteOffset: number,
    byteLength: number
  ): Promise<boolean> {
    if (!decoder) {
      throw new Error("Stream decoder is not initialized");
    }

    const packetData = new Uint8ClampedArray(
      packetBuffer,
      byteOffset,
      byteLength
    );

    decoder.addPacket(packetData);
    const state: typeof Module.StreamDecoderState = decoder.state;

    if (state == Module.StreamDecoderState.Failed) {
      return false;
    }

    return true;
  },

  /**
   * @brief Decode a frame if possible
   *
   * @returns True if a frame was decoded, false otherwise
   */
  async decode(): Promise<boolean> {
    for (;;) {
      const state: typeof Module.StreamDecoderState = decoder.state;

      switch (state) {
        case Module.StreamDecoderState.Running: {
          decoder.decode();
          continue;
        }

        case Module.StreamDecoderState.HasFrame: {
          const frameDataPtr: number = decoder.getFrame();
          const frameSize: number = decoder.frameSize;

          // Get reference to WASM memory holding the frame
          const buffer: ArrayBuffer = Module.HEAPU8.buffer;
          const src = new Uint8ClampedArray(buffer, frameDataPtr, frameSize);

          // Allocate new pixel data
          const videoBuffer = new ArrayBuffer(frameSize);
          const dest = new Uint8Array(videoBuffer);

          // Copy pixels
          dest.set(src);

          frameAvailableSubject.next(Transfer(dest.buffer));
          return true;
        }

        case Module.StreamDecoderState.Failed: {
          throw new Error("Streaming decoder failed. See log for error");
        }
      }
    }
  },

  /**
   * @brief Callback to send metadata when it becomes known
   */
  onMetadataAvailable(): Observable<unknown> {
    return Observable.from(metadataAvailableSubject);
  },

  /**
   * @brief Callback to send a frame after being decoded
   */
  onFrameAvailable(): Observable<unknown> {
    return Observable.from(frameAvailableSubject);
  },
};

expose(streamDecoder);
